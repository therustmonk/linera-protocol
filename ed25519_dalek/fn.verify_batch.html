<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Verify a batch of `signatures` on `messages` with their respective `public_keys`."><title>verify_batch in ed25519_dalek - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-f3501f0f5ae15dfb.css" id="mainThemeStyle"><div id="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="ed25519_dalek" data-themes="" data-resource-suffix="" data-rustdoc-version="1.71.0 (8ede3aae2 2023-07-12)" data-search-js="search-4926e5fc22a5646a.js" data-settings-js="settings-de11bff964e9d4e5.js" data-settings-css="settings-8c76f75bfb6bd192.css" data-theme-light-css="light-0f8c037637f9eb3e.css" data-theme-dark-css="dark-1097f8e92a01e3cf.css" data-theme-ayu-css="ayu-614652228113ac93.css" ></div><script src="../static.files/storage-62ce34ea385b278a.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f0540c1d82cde29b.js"></script><noscript><link rel="stylesheet" media="(prefers-color-scheme:light)" href="../static.files/light-0f8c037637f9eb3e.css"><link rel="stylesheet" media="(prefers-color-scheme:dark)" href="../static.files/dark-1097f8e92a01e3cf.css"><link rel="stylesheet" href="../static.files/noscript-13285aec31fa243e.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="logo-container" href="../ed25519_dalek/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><h2></h2></nav><nav class="sidebar"><a class="logo-container" href="../ed25519_dalek/index.html"><img class="rust-logo" src="../static.files/rust-logo-151179464ae7ed46.svg" alt="logo"></a><div class="sidebar-elems"><h2><a href="index.html">In ed25519_dalek</a></h2></div></nav><main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Function <a href="index.html">ed25519_dalek</a>::<wbr><a class="fn" href="#">verify_batch</a><button id="copy-path" title="Copy item path to clipboard"><img src="../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="srclink" href="../src/ed25519_dalek/batch.rs.html#221-305">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><pre class="rust item-decl"><code>pub fn verify_batch(
    messages: &amp;[&amp;[<a class="primitive" href="https://doc.rust-lang.org/1.71.0/std/primitive.u8.html">u8</a>]],
    signatures: &amp;[<a class="struct" href="struct.Signature.html" title="struct ed25519_dalek::Signature">Signature</a>],
    public_keys: &amp;[<a class="struct" href="struct.PublicKey.html" title="struct ed25519_dalek::PublicKey">PublicKey</a>]
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.71.0/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.71.0/std/primitive.unit.html">()</a>, <a class="type" href="type.SignatureError.html" title="type ed25519_dalek::SignatureError">SignatureError</a>&gt;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Verify a batch of <code>signatures</code> on <code>messages</code> with their respective <code>public_keys</code>.</p>
<h2 id="inputs"><a href="#inputs">Inputs</a></h2>
<ul>
<li><code>messages</code> is a slice of byte slices, one per signed message.</li>
<li><code>signatures</code> is a slice of <code>Signature</code>s.</li>
<li><code>public_keys</code> is a slice of <code>PublicKey</code>s.</li>
</ul>
<h2 id="returns"><a href="#returns">Returns</a></h2>
<ul>
<li>A <code>Result</code> whose <code>Ok</code> value is an emtpy tuple and whose <code>Err</code> value is a
<code>SignatureError</code> containing a description of the internal error which
occured.</li>
</ul>
<h2 id="notes-on-nonce-generation--malleability"><a href="#notes-on-nonce-generation--malleability">Notes on Nonce Generation &amp; Malleability</a></h2><h3 id="on-synthetic-nonces"><a href="#on-synthetic-nonces">On Synthetic Nonces</a></h3>
<p>This library defaults to using what is called “synthetic” nonces, which
means that a mixture of deterministic (per any unique set of inputs to this
function) data and system randomness is used to seed the CSPRNG for nonce
generation.  For more of the background theory on why many cryptographers
currently believe this to be superior to either purely deterministic
generation or purely relying on the system’s randomness, see <a href="https://merlin.cool/transcript/rng.html">this section
of the Merlin design</a> by Henry de
Valence, isis lovecruft, and Oleg Andreev, as well as Trevor Perrin’s
<a href="https://moderncrypto.org/mail-archive/curves/2017/000925.html">designs for generalised
EdDSA</a>.</p>
<h3 id="on-deterministic-nonces"><a href="#on-deterministic-nonces">On Deterministic Nonces</a></h3>
<p>In order to be ammenable to protocols which require stricter third-party
auditability trails, such as in some financial cryptographic settings, this
library also supports a <code>--features=batch_deterministic</code> setting, where the
nonces for batch signature verification are derived purely from the inputs
to this function themselves.</p>
<p><strong>This is not recommended for use unless you have several cryptographers on
staff who can advise you in its usage and all the horrible, terrible,
awful ways it can go horribly, terribly, awfully wrong.</strong></p>
<p>In any sigma protocol it is wise to include as much context pertaining
to the public state in the protocol as possible, to avoid malleability
attacks where an adversary alters publics in an algebraic manner that
manages to satisfy the equations for the protocol in question.</p>
<p>For ed25519 batch verification (both with synthetic and deterministic nonce
generation), we include the following as scalars in the protocol transcript:</p>
<ul>
<li>All of the computed <code>H(R||A||M)</code>s to the protocol transcript, and</li>
<li>All of the <code>s</code> components of each signature.</li>
</ul>
<p>Each is also prefixed with their index in the vector.</p>
<p>The former, while not quite as elegant as adding the <code>R</code>s, <code>A</code>s, and
<code>M</code>s separately, saves us a bit of context hashing since the
<code>H(R||A||M)</code>s need to be computed for the verification equation anyway.</p>
<p>The latter prevents a malleability attack only found in deterministic batch
signature verification (i.e. only when compiling <code>ed25519-dalek</code> with
<code>--features batch_deterministic</code>) wherein an adversary, without access
to the signing key(s), can take any valid signature, <code>(s,R)</code>, and swap
<code>s</code> with <code>s' = -z1</code>.  This doesn’t contitute a signature forgery, merely
a vulnerability, as the resulting signature will not pass single
signature verification.  (Thanks to Github users @real_or_random and
@jonasnick for pointing out this malleability issue.)</p>
<p>For an additional way in which signatures can be made to probablistically
falsely “pass” the synthethic batch verification equation <em>for the same
inputs</em>, but <em>only some crafted inputs</em> will pass the deterministic batch
single, and neither of these will ever pass single signature verification,
see the documentation for [<code>PublicKey.validate()</code>].</p>
<h2 id="examples"><a href="#examples">Examples</a></h2>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>ed25519_dalek;
<span class="kw">extern crate </span>rand;

<span class="kw">use </span>ed25519_dalek::verify_batch;
<span class="kw">use </span>ed25519_dalek::Keypair;
<span class="kw">use </span>ed25519_dalek::PublicKey;
<span class="kw">use </span>ed25519_dalek::Signer;
<span class="kw">use </span>ed25519_dalek::Signature;
<span class="kw">use </span>rand::rngs::OsRng;

<span class="kw">let </span><span class="kw-2">mut </span>csprng = OsRng{};
<span class="kw">let </span>keypairs: Vec&lt;Keypair&gt; = (<span class="number">0</span>..<span class="number">64</span>).map(|<span class="kw">_</span>| Keypair::generate(<span class="kw-2">&amp;mut </span>csprng)).collect();
<span class="kw">let </span>msg: <span class="kw-2">&amp;</span>[u8] = <span class="string">b&quot;They&#39;re good dogs Brant&quot;</span>;
<span class="kw">let </span>messages: Vec&lt;<span class="kw-2">&amp;</span>[u8]&gt; = (<span class="number">0</span>..<span class="number">64</span>).map(|<span class="kw">_</span>| msg).collect();
<span class="kw">let </span>signatures:  Vec&lt;Signature&gt; = keypairs.iter().map(|key| key.sign(<span class="kw-2">&amp;</span>msg)).collect();
<span class="kw">let </span>public_keys: Vec&lt;PublicKey&gt; = keypairs.iter().map(|key| key.public).collect();

<span class="kw">let </span>result = verify_batch(<span class="kw-2">&amp;</span>messages[..], <span class="kw-2">&amp;</span>signatures[..], <span class="kw-2">&amp;</span>public_keys[..]);
<span class="macro">assert!</span>(result.is_ok());</code></pre></div>
</div></details></section></div></main></body></html>