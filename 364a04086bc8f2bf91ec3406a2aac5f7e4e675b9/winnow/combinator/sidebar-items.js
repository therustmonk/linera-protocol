window.SIDEBAR_ITEMS = {"fn":[["alt","Pick the first successful parser"],["backtrack_err","Transforms an [`ErrMode::Cut`] (unrecoverable) to [`ErrMode::Backtrack`] (recoverable)"],["cond","Calls the parser if the condition is met."],["count","[`Accumulate`] the output of a parser into a container, like `Vec`"],["cut_err","Transforms an [`ErrMode::Backtrack`] (recoverable) to [`ErrMode::Cut`] (unrecoverable)"],["delimited","Sequence three parsers, only returning the output of the second."],["eof","Match the end of the [`Stream`]"],["fail","A parser which always fails."],["fill","Repeats the embedded parser, filling the given slice with results."],["fold_repeat","Repeats the embedded parser `m..=n` times, calling `g` to gather the results"],["fold_repeat0","Repeats the embedded parser, calling `g` to gather the results."],["fold_repeat1","Repeats the embedded parser, calling `g` to gather the results."],["iterator","Repeats the embedded parser, lazily returning the results"],["not","Succeeds if the child parser returns an error."],["opt","Apply a [`Parser`], producing `None` on [`ErrMode::Backtrack`]."],["peek","Tries to apply its parser without consuming the input."],["permutation","Applies a list of parsers in any order."],["preceded","Sequence two parsers, only returning the output from the second."],["repeat","[`Accumulate`] the output of a parser into a container, like `Vec`"],["repeat0","[`Accumulate`] the output of a parser into a container, like `Vec`"],["repeat1","[`Accumulate`] the output of a parser into a container, like `Vec`"],["repeat_till0","[`Accumulate`] the output of parser `f` into a container, like `Vec`, until the parser `g` produces a result."],["rest","Return the remaining input."],["rest_len","Return the length of the remaining input."],["separated0","[`Accumulate`] the output of a parser, interleaed with `sep`"],["separated1","[`Accumulate`] the output of a parser, interleaed with `sep`"],["separated_foldl1","Alternates between two parsers, merging the results (left associative)"],["separated_foldr1","Alternates between two parsers, merging the results (right associative)"],["separated_pair","Sequence three parsers, only returning the values of the first and third."],["success","Always succeeds with given value without consuming any input."],["terminated","Sequence two parsers, only returning the output of the first."],["todo","A placeholder for a not-yet-implemented [`Parser`]"]],"macro":[["dispatch","`match` for parsers"]],"struct":[["AndThen","Implementation of [`Parser::and_then`]"],["ByRef","Implementation of [`Parser::by_ref`][Parser::by_ref]"],["CompleteErr","Implementation of [`Parser::complete_err`]"],["Context","Implementation of [`Parser::context`]"],["ErrInto","Implementation of [`Parser::err_into`]"],["FlatMap","Implementation of [`Parser::flat_map`]"],["Map","Implementation of [`Parser::map`]"],["MapRes","Implementation of [`Parser::try_map`]"],["OutputInto","Implementation of [`Parser::output_into`]"],["ParseTo","Implementation of [`Parser::parse_to`]"],["ParserIterator","Main structure associated to [`iterator`]."],["Recognize","Implementation of [`Parser::recognize`]"],["Span","Implementation of [`Parser::span`]"],["TryMap","Implementation of [`Parser::try_map`]"],["Value","Implementation of [`Parser::value`]"],["Verify","Implementation of [`Parser::verify`]"],["VerifyMap","Implementation of [`Parser::verify_map`]"],["Void","Implementation of [`Parser::void`]"],["WithRecognized","Implementation of [`Parser::with_recognized`]"],["WithSpan","Implementation of [`Parser::with_span`]"]],"trait":[["Alt","Helper trait for the [alt()] combinator."],["Permutation","Helper trait for the [permutation()] combinator."]]};